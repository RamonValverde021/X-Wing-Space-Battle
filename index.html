<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta name="author" content="Ramon Valverde">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="Jogo estilo retrô de combate espacial inspirado em StarWars">
    <title>StarWars - X-Wing Space Battle</title>
    <link rel="icon" href="./images/icon-192.png">
    <link rel="manifest" href="./manifest.json">
    <link rel="stylesheet" type="text/css" href="./css/styles.css">
    <link rel="stylesheet" type="text/css" href="./css/smartphone-size.css">
    <script language="JavaScript" src="../javascript/script.js" defer></script>
    <style>
        /* Div de sobreposição para o efeito de fade-to-black */
        #fade-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            opacity: 0;
            pointer-events: none;
            /* Não bloqueia cliques quando invisível */
            transition: opacity 5s ease-out;
            /* Duração da transição de 4 segundos */
            z-index: 20;
            /* Fica acima de tudo, exceto o vídeo */
        }
    </style>
</head>

<body id="index">
    <div id="fade-overlay"></div>
    <div id="rotate-device-overlay" style="display: none;">
        <span>Por favor, gire seu dispositivo para o modo paisagem.</span>
    </div>
    <div id="botoes_Index" class="painel_botoes">
        <button id="playIntro" class="botaoIndex">❰ &nbsp;&nbsp; Iniciar &nbsp; Jogo &nbsp;&nbsp; ❱</button>
        <a id="btnManualControles" class="botaoIndex" href="./html/manualControles.html">❰ &nbsp;&nbsp; Controles
            &nbsp;&nbsp; ❱</a>
    </div>

    <video id="introVideo" src="./images/Intro_X-Wing_Space_Battle.mp4"></video>
    <script>
        const botoes = document.getElementById("botoes_Index");
        const btnIniciar = document.getElementById("playIntro");
        const btnControles = document.getElementById("btnManualControles");
        const video = document.getElementById("introVideo");
        const fadeOverlay = document.getElementById("fade-overlay");
        let iniciouGame = true;

        // Inicia com o botão Iniciar selecionado
        btnIniciar.className = "botaoIndexSelecionado";
        btnControles.className = "botaoIndex";

        btnIniciar.addEventListener("click", function () {
            // Esconde os botões.
            botoes.style.display = "none"; // Esconde os botões para uma transição mais limpa

            // Tenta entrar em modo tela cheia e travar a orientação
            // Isso é ideal para jogos em dispositivos móveis
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().then(() => {
                    if (screen.orientation && screen.orientation.lock) {
                        screen.orientation.lock('landscape').catch(err => console.log(err));
                    }
                }).catch(err => console.log(err));
            }

            // Inicia o áudio e o fade-in da sobreposição ao mesmo tempo.
            const obiWanAudio = new Audio('./audios/forca_sempre_com_vc.mp3');
            obiWanAudio.volume = 1.0;
            obiWanAudio.play();
            fadeOverlay.style.opacity = 1; // Inicia a transição de opacidade.

            // Quando o áudio (e o fade) terminarem, inicia o vídeo.
            obiWanAudio.addEventListener("ended", () => {
                video.style.display = "block";
                video.play();
            });








            // Define uma função assíncrona para poder usar 'await' para esperar por ações.
            async function lockOrientation() {
                try {                                                                                          // Inicia um bloco 'try' para capturar erros que possam ocorrer ao tentar entrar em tela cheia ou bloquear a orientação.
                    // Primeiro, tentamos entrar em tela cheia. É um requisito para o bloqueio de orientação na maioria dos navegadores.
                    if (document.documentElement.requestFullscreen) {                                          // Verifica se o método padrão 'requestFullscreen' existe.
                        await document.documentElement.requestFullscreen();                                    // Solicita o modo de tela cheia e espera a operação ser concluída.
                    } else if (document.documentElement.mozRequestFullScreen) {                                // Firefox  // Se não, verifica a versão para Firefox.
                        await document.documentElement.mozRequestFullScreen();                                 // Solicita tela cheia no Firefox e espera.
                    } else if (document.documentElement.webkitRequestFullscreen) {                             // Chrome, Safari & Opera  // Se não, verifica a versão para Chrome, Safari e Opera.
                        await document.documentElement.webkitRequestFullscreen();                              // Solicita tela cheia nesses navegadores e espera.
                    } else if (document.documentElement.msRequestFullscreen) {                                 // IE/Edge  // Se não, verifica a versão para IE/Edge.
                        await document.documentElement.msRequestFullscreen();                                  // Solicita tela cheia no IE/Edge e espera.
                    }
                    // Depois de entrar em tela cheia com sucesso, bloqueamos a orientação.
                    await screen.orientation.lock('landscape');                                                // Tenta travar a orientação da tela no modo paisagem ('landscape') e espera.
                } catch (error) {                                                                              // Se qualquer uma das solicitações ('await') falhar, o código dentro do 'catch' é executado.
                    console.error("Não foi possível bloquear a orientação da tela:", error);                   // Exibe uma mensagem de erro no console do navegador.
                }
            }




        if (window.screen && screen.orientation && screen.orientation.lock) lockOrientation();         // Tenta bloquear a orientação para paisagem




        }, { once: true }); // Garante que o evento de clique seja acionado apenas uma vez



        btnIniciar.addEventListener("mouseover", () => {
            btnIniciar.className = "botaoIndexSelecionado";
            btnIniciar.style.cursor = "pointer";
            if (btnControles.className === "botaoIndexSelecionado") btnControles.className = "botaoIndex";
        });

        btnControles.addEventListener("mouseover", () => {
            btnControles.className = "botaoIndexSelecionado";
            btnControles.style.cursor = "pointer";
            if (btnIniciar.className === "botaoIndexSelecionado") btnIniciar.className = "botaoIndex";
        });

        btnIniciar.addEventListener("mouseout", () => {
            btnIniciar.className = "botaoIndex";
        });

        btnControles.addEventListener("mouseout", () => {
            btnControles.className = "botaoIndex";
        });

        // quando o vídeo terminar → redireciona para o jogo
        video.addEventListener("ended", () => {
            window.location.href = "./html/game.html"; // troca para a página do game
        });

        // Script para ler entradas do controle de X-Box
        window.addEventListener("gamepadconnected", (e) => {
            // Guarda o estado dos botões do frame anterior para detectar cliques (ações de um toque)
            let prevButtons = [];
            // loop para ler as entradas do controle a cada frame
            function update() {                                               // Inicia o loop de atualização que lê as entradas do controle a cada quadro.
                const gp = navigator.getGamepads()[e.gamepad.index];          // Pega o estado atual do gamepad conectado.
                if (!gp) {                                                    // Verifica se o gamepad foi desconectado.
                    // Se o controle for desconectado, para a nave
                    requestAnimationFrame(update);                            // Continua o loop de atualização no próximo quadro.
                    return;                                                   // Sai da função neste quadro, pois não há controle para ler.
                }
                gp.buttons.forEach((button, index) => {                                                            // Itera sobre todos os botões para verificar cliques únicos.
                    const foiClicado = button.pressed && (!prevButtons[index] || !prevButtons[index].pressed);     // Verifica se o botão foi pressionado neste quadro, mas não no anterior.
                    if (foiClicado) {
                        if (index === 9 || index === 0) {        // Botão Start ou A
                            const botoes = document.getElementById("botoes_Index");
                            const btnIniciar = document.getElementById("playIntro");
                            const btnControles = document.getElementById("btnManualControles");
                            const video = document.getElementById("introVideo");
                            if (btnIniciar.className === "botaoIndexSelecionado") {
                                if (iniciouGame) {
                                    iniciouGame = false;
                                    botoes.style.display = "none"; // Esconde os botões para uma transição mais limpa
                                    const obiWanAudio = new Audio('./audios/forca_sempre_com_vc.mp3');
                                    obiWanAudio.volume = 1.0;
                                    obiWanAudio.play();
                                    fadeOverlay.style.opacity = 1; // Inicia a transição de opacidade.
                                    obiWanAudio.addEventListener("ended", () => {
                                        video.style.display = "block";
                                        video.play();
                                    });
                                }
                            } else if (btnControles.className === "botaoIndexSelecionado") {
                                window.location.href = './html/manualControles.html';
                            }
                        } else if (index === 14) {               // Botão Seta Esquerda
                            document.getElementById("playIntro").className = "botaoIndexSelecionado";
                            document.getElementById("btnManualControles").className = "botaoIndex";
                        } else if (index === 15) {               // Botão Seta Direita
                            document.getElementById("playIntro").className = "botaoIndex";
                            document.getElementById("btnManualControles").className = "botaoIndexSelecionado";
                        }
                    }
                });
                // Salva o estado atual dos botões para comparar no próximo frame
                prevButtons = gp.buttons.map(b => ({ pressed: b.pressed, value: b.value }));  // Salva o estado atual de todos os botões para a próxima verificação.
                requestAnimationFrame(update);                                                // Agenda a próxima execução da função 'update' para o próximo quadro de animação.
            }
            update();
        });

        window.addEventListener("gamepaddisconnected", (e) => {   // Adiciona um ouvinte de evento para quando um controle é desconectado.
            console.log("Controle desconectado:", e.gamepad);     // Exibe no console que o controle foi desconectado.
        });
    </script>
</body>

</html>